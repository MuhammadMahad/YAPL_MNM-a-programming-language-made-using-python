Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDAND
    COMPLEX
    FIRE
    LBRACE
    LSQUAREPAREN
    MACHINE
    MAYBE
    OR
    OROR
    RBRACE
    RSQUAREPAREN
    SEMICOLON
    TIL
    UNTIL
    WORK

Grammar

Rule 0     S' -> yapl_mnm
Rule 1     yapl_mnm -> exp
Rule 2     yapl_mnm -> assign_identifier
Rule 3     yapl_mnm -> snake_list
Rule 4     yapl_mnm -> snake_list_access
Rule 5     yapl_mnm -> rel_exp
Rule 6     yapl_mnm -> empty
Rule 7     snake_list -> SNAKE IDENTIFIER EQUAL num_snake
Rule 8     snake_list -> SNAKE IDENTIFIER EQUAL string_snake
Rule 9     snake_list -> SNAKE IDENTIFIER EQUAL bool_snake
Rule 10    snake_list_access -> ACCESS IDENTIFIER NUMBER
Rule 11    num_snake -> num_snake COMMA NUMBER
Rule 12    num_snake -> NUMBER
Rule 13    num_snake -> empty
Rule 14    string_snake -> string_snake COMMA STRING
Rule 15    string_snake -> STRING
Rule 16    string_snake -> empty
Rule 17    bool_snake -> bool_snake COMMA bool
Rule 18    bool_snake -> bool
Rule 19    empty -> <empty>
Rule 20    assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp
Rule 21    assign_identifier -> IDENTIFIER EQUAL exp
Rule 22    exp -> exp TIMES exp
Rule 23    exp -> exp DIVIDE exp
Rule 24    exp -> exp PLUS exp
Rule 25    exp -> exp MINUS exp
Rule 26    exp -> exp MOD exp
Rule 27    exp -> LPAREN exp RPAREN
Rule 28    exp -> exp PLUSPLUS
Rule 29    exp -> exp MINUSMINUS
Rule 30    exp -> MINUS exp
Rule 31    exp -> NUMBER
Rule 32    exp -> STRING
Rule 33    exp -> bool
Rule 34    bool -> TRUE
Rule 35    bool -> FALSE
Rule 36    exp -> IDENTIFIER
Rule 37    rel_exp -> exp GE exp
Rule 38    rel_exp -> exp GT exp
Rule 39    rel_exp -> exp LE exp
Rule 40    rel_exp -> exp LT exp
Rule 41    rel_exp -> exp EQUALEQUAL exp
Rule 42    rel_exp -> exp NOT EQUAL exp

Terminals, with rules where they appear

ACCESS               : 10
ANDAND               : 
COMMA                : 11 14 17
COMPLEX              : 
DIVIDE               : 23
EQUAL                : 7 8 9 20 21 42
EQUALEQUAL           : 41
FALSE                : 35
FIRE                 : 
GE                   : 37
GT                   : 38
IDENTIFIER           : 7 8 9 10 20 21 36
LBRACE               : 
LE                   : 39
LPAREN               : 27
LSQUAREPAREN         : 
LT                   : 40
MACHINE              : 
MAYBE                : 
MINUS                : 25 30
MINUSMINUS           : 29
MOD                  : 26
NOT                  : 42
NUMBER               : 10 11 12 31
OR                   : 
OROR                 : 
PLUS                 : 24
PLUSPLUS             : 28
RBRACE               : 
RPAREN               : 27
RSQUAREPAREN         : 
SEMICOLON            : 
SNAKE                : 7 8 9
STRING               : 14 15 32
SUPPOSE              : 20
TIL                  : 
TIMES                : 22
TRUE                 : 34
UNTIL                : 
WORK                 : 
error                : 

Nonterminals, with rules where they appear

assign_identifier    : 2
bool                 : 17 18 33
bool_snake           : 9 17
empty                : 6 13 16
exp                  : 1 20 21 22 22 23 23 24 24 25 25 26 26 27 28 29 30 37 37 38 38 39 39 40 40 41 41 42 42
num_snake            : 7 11
rel_exp              : 5
snake_list           : 3
snake_list_access    : 4
string_snake         : 8 14
yapl_mnm             : 0

Parsing method: LALR

state 0

    (0) S' -> . yapl_mnm
    (1) yapl_mnm -> . exp
    (2) yapl_mnm -> . assign_identifier
    (3) yapl_mnm -> . snake_list
    (4) yapl_mnm -> . snake_list_access
    (5) yapl_mnm -> . rel_exp
    (6) yapl_mnm -> . empty
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (20) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (21) assign_identifier -> . IDENTIFIER EQUAL exp
    (7) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (8) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (9) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (10) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (37) rel_exp -> . exp GE exp
    (38) rel_exp -> . exp GT exp
    (39) rel_exp -> . exp LE exp
    (40) rel_exp -> . exp LT exp
    (41) rel_exp -> . exp EQUALEQUAL exp
    (42) rel_exp -> . exp NOT EQUAL exp
    (19) empty -> .
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 19 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    yapl_mnm                       shift and go to state 1
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 1

    (0) S' -> yapl_mnm .



state 2

    (1) yapl_mnm -> exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS
    (37) rel_exp -> exp . GE exp
    (38) rel_exp -> exp . GT exp
    (39) rel_exp -> exp . LE exp
    (40) rel_exp -> exp . LT exp
    (41) rel_exp -> exp . EQUALEQUAL exp
    (42) rel_exp -> exp . NOT EQUAL exp

    $end            reduce using rule 1 (yapl_mnm -> exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25
    GE              shift and go to state 26
    GT              shift and go to state 27
    LE              shift and go to state 28
    LT              shift and go to state 29
    EQUALEQUAL      shift and go to state 30
    NOT             shift and go to state 31


state 3

    (2) yapl_mnm -> assign_identifier .

    $end            reduce using rule 2 (yapl_mnm -> assign_identifier .)


state 4

    (3) yapl_mnm -> snake_list .

    $end            reduce using rule 3 (yapl_mnm -> snake_list .)


state 5

    (4) yapl_mnm -> snake_list_access .

    $end            reduce using rule 4 (yapl_mnm -> snake_list_access .)


state 6

    (5) yapl_mnm -> rel_exp .

    $end            reduce using rule 5 (yapl_mnm -> rel_exp .)


state 7

    (6) yapl_mnm -> empty .

    $end            reduce using rule 6 (yapl_mnm -> empty .)


state 8

    (30) exp -> MINUS . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 32
    bool                           shift and go to state 12

state 9

    (27) exp -> LPAREN . exp RPAREN
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 34
    bool                           shift and go to state 12

state 10

    (31) exp -> NUMBER .

    TIMES           reduce using rule 31 (exp -> NUMBER .)
    DIVIDE          reduce using rule 31 (exp -> NUMBER .)
    PLUS            reduce using rule 31 (exp -> NUMBER .)
    MINUS           reduce using rule 31 (exp -> NUMBER .)
    MOD             reduce using rule 31 (exp -> NUMBER .)
    PLUSPLUS        reduce using rule 31 (exp -> NUMBER .)
    MINUSMINUS      reduce using rule 31 (exp -> NUMBER .)
    GE              reduce using rule 31 (exp -> NUMBER .)
    GT              reduce using rule 31 (exp -> NUMBER .)
    LE              reduce using rule 31 (exp -> NUMBER .)
    LT              reduce using rule 31 (exp -> NUMBER .)
    EQUALEQUAL      reduce using rule 31 (exp -> NUMBER .)
    NOT             reduce using rule 31 (exp -> NUMBER .)
    $end            reduce using rule 31 (exp -> NUMBER .)
    RPAREN          reduce using rule 31 (exp -> NUMBER .)


state 11

    (32) exp -> STRING .

    TIMES           reduce using rule 32 (exp -> STRING .)
    DIVIDE          reduce using rule 32 (exp -> STRING .)
    PLUS            reduce using rule 32 (exp -> STRING .)
    MINUS           reduce using rule 32 (exp -> STRING .)
    MOD             reduce using rule 32 (exp -> STRING .)
    PLUSPLUS        reduce using rule 32 (exp -> STRING .)
    MINUSMINUS      reduce using rule 32 (exp -> STRING .)
    GE              reduce using rule 32 (exp -> STRING .)
    GT              reduce using rule 32 (exp -> STRING .)
    LE              reduce using rule 32 (exp -> STRING .)
    LT              reduce using rule 32 (exp -> STRING .)
    EQUALEQUAL      reduce using rule 32 (exp -> STRING .)
    NOT             reduce using rule 32 (exp -> STRING .)
    $end            reduce using rule 32 (exp -> STRING .)
    RPAREN          reduce using rule 32 (exp -> STRING .)


state 12

    (33) exp -> bool .

    TIMES           reduce using rule 33 (exp -> bool .)
    DIVIDE          reduce using rule 33 (exp -> bool .)
    PLUS            reduce using rule 33 (exp -> bool .)
    MINUS           reduce using rule 33 (exp -> bool .)
    MOD             reduce using rule 33 (exp -> bool .)
    PLUSPLUS        reduce using rule 33 (exp -> bool .)
    MINUSMINUS      reduce using rule 33 (exp -> bool .)
    GE              reduce using rule 33 (exp -> bool .)
    GT              reduce using rule 33 (exp -> bool .)
    LE              reduce using rule 33 (exp -> bool .)
    LT              reduce using rule 33 (exp -> bool .)
    EQUALEQUAL      reduce using rule 33 (exp -> bool .)
    NOT             reduce using rule 33 (exp -> bool .)
    $end            reduce using rule 33 (exp -> bool .)
    RPAREN          reduce using rule 33 (exp -> bool .)


state 13

    (36) exp -> IDENTIFIER .
    (21) assign_identifier -> IDENTIFIER . EQUAL exp

    TIMES           reduce using rule 36 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 36 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 36 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 36 (exp -> IDENTIFIER .)
    MOD             reduce using rule 36 (exp -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 36 (exp -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 36 (exp -> IDENTIFIER .)
    GE              reduce using rule 36 (exp -> IDENTIFIER .)
    GT              reduce using rule 36 (exp -> IDENTIFIER .)
    LE              reduce using rule 36 (exp -> IDENTIFIER .)
    LT              reduce using rule 36 (exp -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 36 (exp -> IDENTIFIER .)
    NOT             reduce using rule 36 (exp -> IDENTIFIER .)
    $end            reduce using rule 36 (exp -> IDENTIFIER .)
    EQUAL           shift and go to state 35


state 14

    (20) assign_identifier -> SUPPOSE . IDENTIFIER EQUAL exp

    IDENTIFIER      shift and go to state 36


state 15

    (7) snake_list -> SNAKE . IDENTIFIER EQUAL num_snake
    (8) snake_list -> SNAKE . IDENTIFIER EQUAL string_snake
    (9) snake_list -> SNAKE . IDENTIFIER EQUAL bool_snake

    IDENTIFIER      shift and go to state 37


state 16

    (10) snake_list_access -> ACCESS . IDENTIFIER NUMBER

    IDENTIFIER      shift and go to state 38


state 17

    (34) bool -> TRUE .

    TIMES           reduce using rule 34 (bool -> TRUE .)
    DIVIDE          reduce using rule 34 (bool -> TRUE .)
    PLUS            reduce using rule 34 (bool -> TRUE .)
    MINUS           reduce using rule 34 (bool -> TRUE .)
    MOD             reduce using rule 34 (bool -> TRUE .)
    PLUSPLUS        reduce using rule 34 (bool -> TRUE .)
    MINUSMINUS      reduce using rule 34 (bool -> TRUE .)
    GE              reduce using rule 34 (bool -> TRUE .)
    GT              reduce using rule 34 (bool -> TRUE .)
    LE              reduce using rule 34 (bool -> TRUE .)
    LT              reduce using rule 34 (bool -> TRUE .)
    EQUALEQUAL      reduce using rule 34 (bool -> TRUE .)
    NOT             reduce using rule 34 (bool -> TRUE .)
    $end            reduce using rule 34 (bool -> TRUE .)
    RPAREN          reduce using rule 34 (bool -> TRUE .)
    COMMA           reduce using rule 34 (bool -> TRUE .)


state 18

    (35) bool -> FALSE .

    TIMES           reduce using rule 35 (bool -> FALSE .)
    DIVIDE          reduce using rule 35 (bool -> FALSE .)
    PLUS            reduce using rule 35 (bool -> FALSE .)
    MINUS           reduce using rule 35 (bool -> FALSE .)
    MOD             reduce using rule 35 (bool -> FALSE .)
    PLUSPLUS        reduce using rule 35 (bool -> FALSE .)
    MINUSMINUS      reduce using rule 35 (bool -> FALSE .)
    GE              reduce using rule 35 (bool -> FALSE .)
    GT              reduce using rule 35 (bool -> FALSE .)
    LE              reduce using rule 35 (bool -> FALSE .)
    LT              reduce using rule 35 (bool -> FALSE .)
    EQUALEQUAL      reduce using rule 35 (bool -> FALSE .)
    NOT             reduce using rule 35 (bool -> FALSE .)
    $end            reduce using rule 35 (bool -> FALSE .)
    RPAREN          reduce using rule 35 (bool -> FALSE .)
    COMMA           reduce using rule 35 (bool -> FALSE .)


state 19

    (22) exp -> exp TIMES . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 39
    bool                           shift and go to state 12

state 20

    (23) exp -> exp DIVIDE . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 40
    bool                           shift and go to state 12

state 21

    (24) exp -> exp PLUS . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 41
    bool                           shift and go to state 12

state 22

    (25) exp -> exp MINUS . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 42
    bool                           shift and go to state 12

state 23

    (26) exp -> exp MOD . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 43
    bool                           shift and go to state 12

state 24

    (28) exp -> exp PLUSPLUS .

    TIMES           reduce using rule 28 (exp -> exp PLUSPLUS .)
    DIVIDE          reduce using rule 28 (exp -> exp PLUSPLUS .)
    PLUS            reduce using rule 28 (exp -> exp PLUSPLUS .)
    MINUS           reduce using rule 28 (exp -> exp PLUSPLUS .)
    MOD             reduce using rule 28 (exp -> exp PLUSPLUS .)
    PLUSPLUS        reduce using rule 28 (exp -> exp PLUSPLUS .)
    MINUSMINUS      reduce using rule 28 (exp -> exp PLUSPLUS .)
    GE              reduce using rule 28 (exp -> exp PLUSPLUS .)
    GT              reduce using rule 28 (exp -> exp PLUSPLUS .)
    LE              reduce using rule 28 (exp -> exp PLUSPLUS .)
    LT              reduce using rule 28 (exp -> exp PLUSPLUS .)
    EQUALEQUAL      reduce using rule 28 (exp -> exp PLUSPLUS .)
    NOT             reduce using rule 28 (exp -> exp PLUSPLUS .)
    $end            reduce using rule 28 (exp -> exp PLUSPLUS .)
    RPAREN          reduce using rule 28 (exp -> exp PLUSPLUS .)


state 25

    (29) exp -> exp MINUSMINUS .

    TIMES           reduce using rule 29 (exp -> exp MINUSMINUS .)
    DIVIDE          reduce using rule 29 (exp -> exp MINUSMINUS .)
    PLUS            reduce using rule 29 (exp -> exp MINUSMINUS .)
    MINUS           reduce using rule 29 (exp -> exp MINUSMINUS .)
    MOD             reduce using rule 29 (exp -> exp MINUSMINUS .)
    PLUSPLUS        reduce using rule 29 (exp -> exp MINUSMINUS .)
    MINUSMINUS      reduce using rule 29 (exp -> exp MINUSMINUS .)
    GE              reduce using rule 29 (exp -> exp MINUSMINUS .)
    GT              reduce using rule 29 (exp -> exp MINUSMINUS .)
    LE              reduce using rule 29 (exp -> exp MINUSMINUS .)
    LT              reduce using rule 29 (exp -> exp MINUSMINUS .)
    EQUALEQUAL      reduce using rule 29 (exp -> exp MINUSMINUS .)
    NOT             reduce using rule 29 (exp -> exp MINUSMINUS .)
    $end            reduce using rule 29 (exp -> exp MINUSMINUS .)
    RPAREN          reduce using rule 29 (exp -> exp MINUSMINUS .)


state 26

    (37) rel_exp -> exp GE . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 44
    bool                           shift and go to state 12

state 27

    (38) rel_exp -> exp GT . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 45
    bool                           shift and go to state 12

state 28

    (39) rel_exp -> exp LE . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 46
    bool                           shift and go to state 12

state 29

    (40) rel_exp -> exp LT . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 47
    bool                           shift and go to state 12

state 30

    (41) rel_exp -> exp EQUALEQUAL . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 48
    bool                           shift and go to state 12

state 31

    (42) rel_exp -> exp NOT . EQUAL exp

    EQUAL           shift and go to state 49


state 32

    (30) exp -> MINUS exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 30 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 30 (exp -> MINUS exp .)
    PLUS            reduce using rule 30 (exp -> MINUS exp .)
    MINUS           reduce using rule 30 (exp -> MINUS exp .)
    MOD             reduce using rule 30 (exp -> MINUS exp .)
    PLUSPLUS        reduce using rule 30 (exp -> MINUS exp .)
    MINUSMINUS      reduce using rule 30 (exp -> MINUS exp .)
    GE              reduce using rule 30 (exp -> MINUS exp .)
    GT              reduce using rule 30 (exp -> MINUS exp .)
    LE              reduce using rule 30 (exp -> MINUS exp .)
    LT              reduce using rule 30 (exp -> MINUS exp .)
    EQUALEQUAL      reduce using rule 30 (exp -> MINUS exp .)
    NOT             reduce using rule 30 (exp -> MINUS exp .)
    $end            reduce using rule 30 (exp -> MINUS exp .)
    RPAREN          reduce using rule 30 (exp -> MINUS exp .)

  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! MOD             [ shift and go to state 23 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 33

    (36) exp -> IDENTIFIER .

    TIMES           reduce using rule 36 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 36 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 36 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 36 (exp -> IDENTIFIER .)
    MOD             reduce using rule 36 (exp -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 36 (exp -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 36 (exp -> IDENTIFIER .)
    GE              reduce using rule 36 (exp -> IDENTIFIER .)
    GT              reduce using rule 36 (exp -> IDENTIFIER .)
    LE              reduce using rule 36 (exp -> IDENTIFIER .)
    LT              reduce using rule 36 (exp -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 36 (exp -> IDENTIFIER .)
    NOT             reduce using rule 36 (exp -> IDENTIFIER .)
    $end            reduce using rule 36 (exp -> IDENTIFIER .)
    RPAREN          reduce using rule 36 (exp -> IDENTIFIER .)


state 34

    (27) exp -> LPAREN exp . RPAREN
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    RPAREN          shift and go to state 50
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 35

    (21) assign_identifier -> IDENTIFIER EQUAL . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 51
    bool                           shift and go to state 12

state 36

    (20) assign_identifier -> SUPPOSE IDENTIFIER . EQUAL exp

    EQUAL           shift and go to state 52


state 37

    (7) snake_list -> SNAKE IDENTIFIER . EQUAL num_snake
    (8) snake_list -> SNAKE IDENTIFIER . EQUAL string_snake
    (9) snake_list -> SNAKE IDENTIFIER . EQUAL bool_snake

    EQUAL           shift and go to state 53


state 38

    (10) snake_list_access -> ACCESS IDENTIFIER . NUMBER

    NUMBER          shift and go to state 54


state 39

    (22) exp -> exp TIMES exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 22 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 22 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 22 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 22 (exp -> exp TIMES exp .)
    MOD             reduce using rule 22 (exp -> exp TIMES exp .)
    PLUSPLUS        reduce using rule 22 (exp -> exp TIMES exp .)
    MINUSMINUS      reduce using rule 22 (exp -> exp TIMES exp .)
    GE              reduce using rule 22 (exp -> exp TIMES exp .)
    GT              reduce using rule 22 (exp -> exp TIMES exp .)
    LE              reduce using rule 22 (exp -> exp TIMES exp .)
    LT              reduce using rule 22 (exp -> exp TIMES exp .)
    EQUALEQUAL      reduce using rule 22 (exp -> exp TIMES exp .)
    NOT             reduce using rule 22 (exp -> exp TIMES exp .)
    $end            reduce using rule 22 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 22 (exp -> exp TIMES exp .)

  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! MOD             [ shift and go to state 23 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 40

    (23) exp -> exp DIVIDE exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 23 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 23 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 23 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 23 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 23 (exp -> exp DIVIDE exp .)
    PLUSPLUS        reduce using rule 23 (exp -> exp DIVIDE exp .)
    MINUSMINUS      reduce using rule 23 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 23 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 23 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 23 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 23 (exp -> exp DIVIDE exp .)
    EQUALEQUAL      reduce using rule 23 (exp -> exp DIVIDE exp .)
    NOT             reduce using rule 23 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 23 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 23 (exp -> exp DIVIDE exp .)

  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! MOD             [ shift and go to state 23 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 41

    (24) exp -> exp PLUS exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    PLUS            reduce using rule 24 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 24 (exp -> exp PLUS exp .)
    PLUSPLUS        reduce using rule 24 (exp -> exp PLUS exp .)
    MINUSMINUS      reduce using rule 24 (exp -> exp PLUS exp .)
    GE              reduce using rule 24 (exp -> exp PLUS exp .)
    GT              reduce using rule 24 (exp -> exp PLUS exp .)
    LE              reduce using rule 24 (exp -> exp PLUS exp .)
    LT              reduce using rule 24 (exp -> exp PLUS exp .)
    EQUALEQUAL      reduce using rule 24 (exp -> exp PLUS exp .)
    NOT             reduce using rule 24 (exp -> exp PLUS exp .)
    $end            reduce using rule 24 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 24 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    MOD             shift and go to state 23

  ! TIMES           [ reduce using rule 24 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 24 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 24 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 42

    (25) exp -> exp MINUS exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    PLUS            reduce using rule 25 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 25 (exp -> exp MINUS exp .)
    PLUSPLUS        reduce using rule 25 (exp -> exp MINUS exp .)
    MINUSMINUS      reduce using rule 25 (exp -> exp MINUS exp .)
    GE              reduce using rule 25 (exp -> exp MINUS exp .)
    GT              reduce using rule 25 (exp -> exp MINUS exp .)
    LE              reduce using rule 25 (exp -> exp MINUS exp .)
    LT              reduce using rule 25 (exp -> exp MINUS exp .)
    EQUALEQUAL      reduce using rule 25 (exp -> exp MINUS exp .)
    NOT             reduce using rule 25 (exp -> exp MINUS exp .)
    $end            reduce using rule 25 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 25 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    MOD             shift and go to state 23

  ! TIMES           [ reduce using rule 25 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 25 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 25 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 43

    (26) exp -> exp MOD exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 26 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 26 (exp -> exp MOD exp .)
    PLUS            reduce using rule 26 (exp -> exp MOD exp .)
    MINUS           reduce using rule 26 (exp -> exp MOD exp .)
    MOD             reduce using rule 26 (exp -> exp MOD exp .)
    PLUSPLUS        reduce using rule 26 (exp -> exp MOD exp .)
    MINUSMINUS      reduce using rule 26 (exp -> exp MOD exp .)
    GE              reduce using rule 26 (exp -> exp MOD exp .)
    GT              reduce using rule 26 (exp -> exp MOD exp .)
    LE              reduce using rule 26 (exp -> exp MOD exp .)
    LT              reduce using rule 26 (exp -> exp MOD exp .)
    EQUALEQUAL      reduce using rule 26 (exp -> exp MOD exp .)
    NOT             reduce using rule 26 (exp -> exp MOD exp .)
    $end            reduce using rule 26 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 26 (exp -> exp MOD exp .)

  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]
  ! PLUS            [ shift and go to state 21 ]
  ! MINUS           [ shift and go to state 22 ]
  ! MOD             [ shift and go to state 23 ]
  ! PLUSPLUS        [ shift and go to state 24 ]
  ! MINUSMINUS      [ shift and go to state 25 ]


state 44

    (37) rel_exp -> exp GE exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 37 (rel_exp -> exp GE exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 45

    (38) rel_exp -> exp GT exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 38 (rel_exp -> exp GT exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 46

    (39) rel_exp -> exp LE exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 39 (rel_exp -> exp LE exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 47

    (40) rel_exp -> exp LT exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 40 (rel_exp -> exp LT exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 48

    (41) rel_exp -> exp EQUALEQUAL exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 41 (rel_exp -> exp EQUALEQUAL exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 49

    (42) rel_exp -> exp NOT EQUAL . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 55
    bool                           shift and go to state 12

state 50

    (27) exp -> LPAREN exp RPAREN .

    TIMES           reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    PLUSPLUS        reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    MINUSMINUS      reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    EQUALEQUAL      reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    NOT             reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 27 (exp -> LPAREN exp RPAREN .)


state 51

    (21) assign_identifier -> IDENTIFIER EQUAL exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 21 (assign_identifier -> IDENTIFIER EQUAL exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 52

    (20) assign_identifier -> SUPPOSE IDENTIFIER EQUAL . exp
    (22) exp -> . exp TIMES exp
    (23) exp -> . exp DIVIDE exp
    (24) exp -> . exp PLUS exp
    (25) exp -> . exp MINUS exp
    (26) exp -> . exp MOD exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . exp PLUSPLUS
    (29) exp -> . exp MINUSMINUS
    (30) exp -> . MINUS exp
    (31) exp -> . NUMBER
    (32) exp -> . STRING
    (33) exp -> . bool
    (36) exp -> . IDENTIFIER
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    LPAREN          shift and go to state 9
    MINUS           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 33
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 56
    bool                           shift and go to state 12

state 53

    (7) snake_list -> SNAKE IDENTIFIER EQUAL . num_snake
    (8) snake_list -> SNAKE IDENTIFIER EQUAL . string_snake
    (9) snake_list -> SNAKE IDENTIFIER EQUAL . bool_snake
    (11) num_snake -> . num_snake COMMA NUMBER
    (12) num_snake -> . NUMBER
    (13) num_snake -> . empty
    (14) string_snake -> . string_snake COMMA STRING
    (15) string_snake -> . STRING
    (16) string_snake -> . empty
    (17) bool_snake -> . bool_snake COMMA bool
    (18) bool_snake -> . bool
    (19) empty -> .
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    NUMBER          shift and go to state 60
    STRING          shift and go to state 62
    COMMA           reduce using rule 19 (empty -> .)
    $end            reduce using rule 19 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    num_snake                      shift and go to state 57
    string_snake                   shift and go to state 58
    bool_snake                     shift and go to state 59
    empty                          shift and go to state 61
    bool                           shift and go to state 63

state 54

    (10) snake_list_access -> ACCESS IDENTIFIER NUMBER .

    $end            reduce using rule 10 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)


state 55

    (42) rel_exp -> exp NOT EQUAL exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 42 (rel_exp -> exp NOT EQUAL exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 56

    (20) assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .
    (22) exp -> exp . TIMES exp
    (23) exp -> exp . DIVIDE exp
    (24) exp -> exp . PLUS exp
    (25) exp -> exp . MINUS exp
    (26) exp -> exp . MOD exp
    (28) exp -> exp . PLUSPLUS
    (29) exp -> exp . MINUSMINUS

    $end            reduce using rule 20 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    PLUS            shift and go to state 21
    MINUS           shift and go to state 22
    MOD             shift and go to state 23
    PLUSPLUS        shift and go to state 24
    MINUSMINUS      shift and go to state 25


state 57

    (7) snake_list -> SNAKE IDENTIFIER EQUAL num_snake .
    (11) num_snake -> num_snake . COMMA NUMBER

    $end            reduce using rule 7 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    COMMA           shift and go to state 64


state 58

    (8) snake_list -> SNAKE IDENTIFIER EQUAL string_snake .
    (14) string_snake -> string_snake . COMMA STRING

    $end            reduce using rule 8 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    COMMA           shift and go to state 65


state 59

    (9) snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .
    (17) bool_snake -> bool_snake . COMMA bool

    $end            reduce using rule 9 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    COMMA           shift and go to state 66


state 60

    (12) num_snake -> NUMBER .

    COMMA           reduce using rule 12 (num_snake -> NUMBER .)
    $end            reduce using rule 12 (num_snake -> NUMBER .)


state 61

    (13) num_snake -> empty .
    (16) string_snake -> empty .

  ! reduce/reduce conflict for COMMA resolved using rule 13 (num_snake -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 13 (num_snake -> empty .)
    COMMA           reduce using rule 13 (num_snake -> empty .)
    $end            reduce using rule 13 (num_snake -> empty .)

  ! COMMA           [ reduce using rule 16 (string_snake -> empty .) ]
  ! $end            [ reduce using rule 16 (string_snake -> empty .) ]


state 62

    (15) string_snake -> STRING .

    COMMA           reduce using rule 15 (string_snake -> STRING .)
    $end            reduce using rule 15 (string_snake -> STRING .)


state 63

    (18) bool_snake -> bool .

    COMMA           reduce using rule 18 (bool_snake -> bool .)
    $end            reduce using rule 18 (bool_snake -> bool .)


state 64

    (11) num_snake -> num_snake COMMA . NUMBER

    NUMBER          shift and go to state 67


state 65

    (14) string_snake -> string_snake COMMA . STRING

    STRING          shift and go to state 68


state 66

    (17) bool_snake -> bool_snake COMMA . bool
    (34) bool -> . TRUE
    (35) bool -> . FALSE

    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    bool                           shift and go to state 69

state 67

    (11) num_snake -> num_snake COMMA NUMBER .

    COMMA           reduce using rule 11 (num_snake -> num_snake COMMA NUMBER .)
    $end            reduce using rule 11 (num_snake -> num_snake COMMA NUMBER .)


state 68

    (14) string_snake -> string_snake COMMA STRING .

    COMMA           reduce using rule 14 (string_snake -> string_snake COMMA STRING .)
    $end            reduce using rule 14 (string_snake -> string_snake COMMA STRING .)


state 69

    (17) bool_snake -> bool_snake COMMA bool .

    COMMA           reduce using rule 17 (bool_snake -> bool_snake COMMA bool .)
    $end            reduce using rule 17 (bool_snake -> bool_snake COMMA bool .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 61 resolved using rule (num_snake -> empty)
WARNING: rejected rule (string_snake -> empty) in state 61
WARNING: Rule (string_snake -> empty) is never reduced

Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDAND
    COMPLEX
    END
    EXPS
    FIRE
    G1
    LPAREN
    LSQUAREPAREN
    MACHINE
    OROR
    PERFORM
    RPAREN
    RSQUAREPAREN
    TIL
    UNTIL
    WORK

Grammar

Rule 0     S' -> yapl_mnm
Rule 1     yapl_mnm -> exp yapl_mnm
Rule 2     yapl_mnm -> assign_identifier yapl_mnm
Rule 3     yapl_mnm -> snake_list yapl_mnm
Rule 4     yapl_mnm -> snake_list_access yapl_mnm
Rule 5     yapl_mnm -> rel_exp yapl_mnm
Rule 6     yapl_mnm -> empty
Rule 7     yapl_mnm -> MAYBE rel_exp compoundstmt
Rule 8     yapl_mnm -> MAYBE rel_exp compoundstmt OR compoundstmt
Rule 9     compoundstmt -> LBRACE statements RBRACE
Rule 10    statements -> yapl_mnm SEMICOLON statements
Rule 11    statements -> <empty>
Rule 12    snake_list -> SNAKE IDENTIFIER EQUAL num_snake
Rule 13    snake_list -> SNAKE IDENTIFIER EQUAL string_snake
Rule 14    snake_list -> SNAKE IDENTIFIER EQUAL bool_snake
Rule 15    snake_list_access -> ACCESS IDENTIFIER NUMBER
Rule 16    num_snake -> num_snake COMMA NUMBER
Rule 17    num_snake -> NUMBER
Rule 18    num_snake -> empty
Rule 19    string_snake -> string_snake COMMA STRING
Rule 20    string_snake -> STRING
Rule 21    string_snake -> empty
Rule 22    bool_snake -> bool_snake COMMA bool
Rule 23    bool_snake -> bool
Rule 24    empty -> <empty>
Rule 25    assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp
Rule 26    assign_identifier -> IDENTIFIER EQUAL exp
Rule 27    exp -> exp TIMES exp
Rule 28    exp -> exp DIVIDE exp
Rule 29    exp -> exp PLUS exp
Rule 30    exp -> exp MINUS exp
Rule 31    exp -> exp MOD exp
Rule 32    exp -> exp PLUSPLUS
Rule 33    exp -> exp MINUSMINUS
Rule 34    exp -> MINUS exp
Rule 35    exp -> NUMBER
Rule 36    exp -> STRING
Rule 37    exp -> bool
Rule 38    bool -> TRUE
Rule 39    bool -> FALSE
Rule 40    exp -> IDENTIFIER
Rule 41    rel_exp -> exp GE exp
Rule 42    rel_exp -> exp GT exp
Rule 43    rel_exp -> exp LE exp
Rule 44    rel_exp -> exp LT exp
Rule 45    rel_exp -> exp EQUALEQUAL exp
Rule 46    rel_exp -> exp NOT EQUAL exp

Terminals, with rules where they appear

ACCESS               : 15
ANDAND               : 
COMMA                : 16 19 22
COMPLEX              : 
DIVIDE               : 28
END                  : 
EQUAL                : 12 13 14 25 26 46
EQUALEQUAL           : 45
EXPS                 : 
FALSE                : 39
FIRE                 : 
G1                   : 
GE                   : 41
GT                   : 42
IDENTIFIER           : 12 13 14 15 25 26 40
LBRACE               : 9
LE                   : 43
LPAREN               : 
LSQUAREPAREN         : 
LT                   : 44
MACHINE              : 
MAYBE                : 7 8
MINUS                : 30 34
MINUSMINUS           : 33
MOD                  : 31
NOT                  : 46
NUMBER               : 15 16 17 35
OR                   : 8
OROR                 : 
PERFORM              : 
PLUS                 : 29
PLUSPLUS             : 32
RBRACE               : 9
RPAREN               : 
RSQUAREPAREN         : 
SEMICOLON            : 10
SNAKE                : 12 13 14
STRING               : 19 20 36
SUPPOSE              : 25
TIL                  : 
TIMES                : 27
TRUE                 : 38
UNTIL                : 
WORK                 : 
error                : 

Nonterminals, with rules where they appear

assign_identifier    : 2
bool                 : 22 23 37
bool_snake           : 14 22
compoundstmt         : 7 8 8
empty                : 6 18 21
exp                  : 1 25 26 27 27 28 28 29 29 30 30 31 31 32 33 34 41 41 42 42 43 43 44 44 45 45 46 46
num_snake            : 12 16
rel_exp              : 5 7 8
snake_list           : 3
snake_list_access    : 4
statements           : 9 10
string_snake         : 13 19
yapl_mnm             : 1 2 3 4 5 10 0

Parsing method: LALR

state 0

    (0) S' -> . yapl_mnm
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    yapl_mnm                       shift and go to state 1
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 1

    (0) S' -> yapl_mnm .



state 2

    (1) yapl_mnm -> exp . yapl_mnm
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS
    (41) rel_exp -> exp . GE exp
    (42) rel_exp -> exp . GT exp
    (43) rel_exp -> exp . LE exp
    (44) rel_exp -> exp . LT exp
    (45) rel_exp -> exp . EQUALEQUAL exp
    (46) rel_exp -> exp . NOT EQUAL exp
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26
    GE              shift and go to state 27
    GT              shift and go to state 28
    LE              shift and go to state 29
    LT              shift and go to state 30
    EQUALEQUAL      shift and go to state 31
    NOT             shift and go to state 32
    MAYBE           shift and go to state 8
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 2
    yapl_mnm                       shift and go to state 19
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 3

    (2) yapl_mnm -> assign_identifier . yapl_mnm
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    assign_identifier              shift and go to state 3
    yapl_mnm                       shift and go to state 33
    exp                            shift and go to state 2
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 4

    (3) yapl_mnm -> snake_list . yapl_mnm
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    snake_list                     shift and go to state 4
    yapl_mnm                       shift and go to state 34
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 5

    (4) yapl_mnm -> snake_list_access . yapl_mnm
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    snake_list_access              shift and go to state 5
    yapl_mnm                       shift and go to state 35
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 6

    (5) yapl_mnm -> rel_exp . yapl_mnm
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    rel_exp                        shift and go to state 6
    yapl_mnm                       shift and go to state 36
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 7

    (6) yapl_mnm -> empty .

    $end            reduce using rule 6 (yapl_mnm -> empty .)
    SEMICOLON       reduce using rule 6 (yapl_mnm -> empty .)


state 8

    (7) yapl_mnm -> MAYBE . rel_exp compoundstmt
    (8) yapl_mnm -> MAYBE . rel_exp compoundstmt OR compoundstmt
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    rel_exp                        shift and go to state 37
    exp                            shift and go to state 38
    bool                           shift and go to state 12

state 9

    (34) exp -> MINUS . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 40
    bool                           shift and go to state 12

state 10

    (35) exp -> NUMBER .

    TIMES           reduce using rule 35 (exp -> NUMBER .)
    DIVIDE          reduce using rule 35 (exp -> NUMBER .)
    PLUS            reduce using rule 35 (exp -> NUMBER .)
    MINUS           reduce using rule 35 (exp -> NUMBER .)
    MOD             reduce using rule 35 (exp -> NUMBER .)
    PLUSPLUS        reduce using rule 35 (exp -> NUMBER .)
    MINUSMINUS      reduce using rule 35 (exp -> NUMBER .)
    GE              reduce using rule 35 (exp -> NUMBER .)
    GT              reduce using rule 35 (exp -> NUMBER .)
    LE              reduce using rule 35 (exp -> NUMBER .)
    LT              reduce using rule 35 (exp -> NUMBER .)
    EQUALEQUAL      reduce using rule 35 (exp -> NUMBER .)
    NOT             reduce using rule 35 (exp -> NUMBER .)
    MAYBE           reduce using rule 35 (exp -> NUMBER .)
    NUMBER          reduce using rule 35 (exp -> NUMBER .)
    STRING          reduce using rule 35 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 35 (exp -> NUMBER .)
    SUPPOSE         reduce using rule 35 (exp -> NUMBER .)
    SNAKE           reduce using rule 35 (exp -> NUMBER .)
    ACCESS          reduce using rule 35 (exp -> NUMBER .)
    TRUE            reduce using rule 35 (exp -> NUMBER .)
    FALSE           reduce using rule 35 (exp -> NUMBER .)
    $end            reduce using rule 35 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 35 (exp -> NUMBER .)
    LBRACE          reduce using rule 35 (exp -> NUMBER .)


state 11

    (36) exp -> STRING .

    TIMES           reduce using rule 36 (exp -> STRING .)
    DIVIDE          reduce using rule 36 (exp -> STRING .)
    PLUS            reduce using rule 36 (exp -> STRING .)
    MINUS           reduce using rule 36 (exp -> STRING .)
    MOD             reduce using rule 36 (exp -> STRING .)
    PLUSPLUS        reduce using rule 36 (exp -> STRING .)
    MINUSMINUS      reduce using rule 36 (exp -> STRING .)
    GE              reduce using rule 36 (exp -> STRING .)
    GT              reduce using rule 36 (exp -> STRING .)
    LE              reduce using rule 36 (exp -> STRING .)
    LT              reduce using rule 36 (exp -> STRING .)
    EQUALEQUAL      reduce using rule 36 (exp -> STRING .)
    NOT             reduce using rule 36 (exp -> STRING .)
    MAYBE           reduce using rule 36 (exp -> STRING .)
    NUMBER          reduce using rule 36 (exp -> STRING .)
    STRING          reduce using rule 36 (exp -> STRING .)
    IDENTIFIER      reduce using rule 36 (exp -> STRING .)
    SUPPOSE         reduce using rule 36 (exp -> STRING .)
    SNAKE           reduce using rule 36 (exp -> STRING .)
    ACCESS          reduce using rule 36 (exp -> STRING .)
    TRUE            reduce using rule 36 (exp -> STRING .)
    FALSE           reduce using rule 36 (exp -> STRING .)
    $end            reduce using rule 36 (exp -> STRING .)
    SEMICOLON       reduce using rule 36 (exp -> STRING .)
    LBRACE          reduce using rule 36 (exp -> STRING .)


state 12

    (37) exp -> bool .

    TIMES           reduce using rule 37 (exp -> bool .)
    DIVIDE          reduce using rule 37 (exp -> bool .)
    PLUS            reduce using rule 37 (exp -> bool .)
    MINUS           reduce using rule 37 (exp -> bool .)
    MOD             reduce using rule 37 (exp -> bool .)
    PLUSPLUS        reduce using rule 37 (exp -> bool .)
    MINUSMINUS      reduce using rule 37 (exp -> bool .)
    GE              reduce using rule 37 (exp -> bool .)
    GT              reduce using rule 37 (exp -> bool .)
    LE              reduce using rule 37 (exp -> bool .)
    LT              reduce using rule 37 (exp -> bool .)
    EQUALEQUAL      reduce using rule 37 (exp -> bool .)
    NOT             reduce using rule 37 (exp -> bool .)
    MAYBE           reduce using rule 37 (exp -> bool .)
    NUMBER          reduce using rule 37 (exp -> bool .)
    STRING          reduce using rule 37 (exp -> bool .)
    IDENTIFIER      reduce using rule 37 (exp -> bool .)
    SUPPOSE         reduce using rule 37 (exp -> bool .)
    SNAKE           reduce using rule 37 (exp -> bool .)
    ACCESS          reduce using rule 37 (exp -> bool .)
    TRUE            reduce using rule 37 (exp -> bool .)
    FALSE           reduce using rule 37 (exp -> bool .)
    $end            reduce using rule 37 (exp -> bool .)
    SEMICOLON       reduce using rule 37 (exp -> bool .)
    LBRACE          reduce using rule 37 (exp -> bool .)


state 13

    (40) exp -> IDENTIFIER .
    (26) assign_identifier -> IDENTIFIER . EQUAL exp

    TIMES           reduce using rule 40 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 40 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 40 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 40 (exp -> IDENTIFIER .)
    MOD             reduce using rule 40 (exp -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 40 (exp -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 40 (exp -> IDENTIFIER .)
    GE              reduce using rule 40 (exp -> IDENTIFIER .)
    GT              reduce using rule 40 (exp -> IDENTIFIER .)
    LE              reduce using rule 40 (exp -> IDENTIFIER .)
    LT              reduce using rule 40 (exp -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 40 (exp -> IDENTIFIER .)
    NOT             reduce using rule 40 (exp -> IDENTIFIER .)
    MAYBE           reduce using rule 40 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 40 (exp -> IDENTIFIER .)
    STRING          reduce using rule 40 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 40 (exp -> IDENTIFIER .)
    SUPPOSE         reduce using rule 40 (exp -> IDENTIFIER .)
    SNAKE           reduce using rule 40 (exp -> IDENTIFIER .)
    ACCESS          reduce using rule 40 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 40 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 40 (exp -> IDENTIFIER .)
    $end            reduce using rule 40 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 40 (exp -> IDENTIFIER .)
    EQUAL           shift and go to state 41


state 14

    (25) assign_identifier -> SUPPOSE . IDENTIFIER EQUAL exp

    IDENTIFIER      shift and go to state 42


state 15

    (12) snake_list -> SNAKE . IDENTIFIER EQUAL num_snake
    (13) snake_list -> SNAKE . IDENTIFIER EQUAL string_snake
    (14) snake_list -> SNAKE . IDENTIFIER EQUAL bool_snake

    IDENTIFIER      shift and go to state 43


state 16

    (15) snake_list_access -> ACCESS . IDENTIFIER NUMBER

    IDENTIFIER      shift and go to state 44


state 17

    (38) bool -> TRUE .

    TIMES           reduce using rule 38 (bool -> TRUE .)
    DIVIDE          reduce using rule 38 (bool -> TRUE .)
    PLUS            reduce using rule 38 (bool -> TRUE .)
    MINUS           reduce using rule 38 (bool -> TRUE .)
    MOD             reduce using rule 38 (bool -> TRUE .)
    PLUSPLUS        reduce using rule 38 (bool -> TRUE .)
    MINUSMINUS      reduce using rule 38 (bool -> TRUE .)
    GE              reduce using rule 38 (bool -> TRUE .)
    GT              reduce using rule 38 (bool -> TRUE .)
    LE              reduce using rule 38 (bool -> TRUE .)
    LT              reduce using rule 38 (bool -> TRUE .)
    EQUALEQUAL      reduce using rule 38 (bool -> TRUE .)
    NOT             reduce using rule 38 (bool -> TRUE .)
    MAYBE           reduce using rule 38 (bool -> TRUE .)
    NUMBER          reduce using rule 38 (bool -> TRUE .)
    STRING          reduce using rule 38 (bool -> TRUE .)
    IDENTIFIER      reduce using rule 38 (bool -> TRUE .)
    SUPPOSE         reduce using rule 38 (bool -> TRUE .)
    SNAKE           reduce using rule 38 (bool -> TRUE .)
    ACCESS          reduce using rule 38 (bool -> TRUE .)
    TRUE            reduce using rule 38 (bool -> TRUE .)
    FALSE           reduce using rule 38 (bool -> TRUE .)
    $end            reduce using rule 38 (bool -> TRUE .)
    SEMICOLON       reduce using rule 38 (bool -> TRUE .)
    LBRACE          reduce using rule 38 (bool -> TRUE .)
    COMMA           reduce using rule 38 (bool -> TRUE .)


state 18

    (39) bool -> FALSE .

    TIMES           reduce using rule 39 (bool -> FALSE .)
    DIVIDE          reduce using rule 39 (bool -> FALSE .)
    PLUS            reduce using rule 39 (bool -> FALSE .)
    MINUS           reduce using rule 39 (bool -> FALSE .)
    MOD             reduce using rule 39 (bool -> FALSE .)
    PLUSPLUS        reduce using rule 39 (bool -> FALSE .)
    MINUSMINUS      reduce using rule 39 (bool -> FALSE .)
    GE              reduce using rule 39 (bool -> FALSE .)
    GT              reduce using rule 39 (bool -> FALSE .)
    LE              reduce using rule 39 (bool -> FALSE .)
    LT              reduce using rule 39 (bool -> FALSE .)
    EQUALEQUAL      reduce using rule 39 (bool -> FALSE .)
    NOT             reduce using rule 39 (bool -> FALSE .)
    MAYBE           reduce using rule 39 (bool -> FALSE .)
    NUMBER          reduce using rule 39 (bool -> FALSE .)
    STRING          reduce using rule 39 (bool -> FALSE .)
    IDENTIFIER      reduce using rule 39 (bool -> FALSE .)
    SUPPOSE         reduce using rule 39 (bool -> FALSE .)
    SNAKE           reduce using rule 39 (bool -> FALSE .)
    ACCESS          reduce using rule 39 (bool -> FALSE .)
    TRUE            reduce using rule 39 (bool -> FALSE .)
    FALSE           reduce using rule 39 (bool -> FALSE .)
    $end            reduce using rule 39 (bool -> FALSE .)
    SEMICOLON       reduce using rule 39 (bool -> FALSE .)
    LBRACE          reduce using rule 39 (bool -> FALSE .)
    COMMA           reduce using rule 39 (bool -> FALSE .)


state 19

    (1) yapl_mnm -> exp yapl_mnm .

    $end            reduce using rule 1 (yapl_mnm -> exp yapl_mnm .)
    SEMICOLON       reduce using rule 1 (yapl_mnm -> exp yapl_mnm .)


state 20

    (27) exp -> exp TIMES . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 45
    bool                           shift and go to state 12

state 21

    (28) exp -> exp DIVIDE . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 46
    bool                           shift and go to state 12

state 22

    (29) exp -> exp PLUS . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 47
    bool                           shift and go to state 12

state 23

    (30) exp -> exp MINUS . exp
    (34) exp -> MINUS . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 48
    bool                           shift and go to state 12

state 24

    (31) exp -> exp MOD . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 49
    bool                           shift and go to state 12

state 25

    (32) exp -> exp PLUSPLUS .

    TIMES           reduce using rule 32 (exp -> exp PLUSPLUS .)
    DIVIDE          reduce using rule 32 (exp -> exp PLUSPLUS .)
    PLUS            reduce using rule 32 (exp -> exp PLUSPLUS .)
    MINUS           reduce using rule 32 (exp -> exp PLUSPLUS .)
    MOD             reduce using rule 32 (exp -> exp PLUSPLUS .)
    PLUSPLUS        reduce using rule 32 (exp -> exp PLUSPLUS .)
    MINUSMINUS      reduce using rule 32 (exp -> exp PLUSPLUS .)
    GE              reduce using rule 32 (exp -> exp PLUSPLUS .)
    GT              reduce using rule 32 (exp -> exp PLUSPLUS .)
    LE              reduce using rule 32 (exp -> exp PLUSPLUS .)
    LT              reduce using rule 32 (exp -> exp PLUSPLUS .)
    EQUALEQUAL      reduce using rule 32 (exp -> exp PLUSPLUS .)
    NOT             reduce using rule 32 (exp -> exp PLUSPLUS .)
    MAYBE           reduce using rule 32 (exp -> exp PLUSPLUS .)
    NUMBER          reduce using rule 32 (exp -> exp PLUSPLUS .)
    STRING          reduce using rule 32 (exp -> exp PLUSPLUS .)
    IDENTIFIER      reduce using rule 32 (exp -> exp PLUSPLUS .)
    SUPPOSE         reduce using rule 32 (exp -> exp PLUSPLUS .)
    SNAKE           reduce using rule 32 (exp -> exp PLUSPLUS .)
    ACCESS          reduce using rule 32 (exp -> exp PLUSPLUS .)
    TRUE            reduce using rule 32 (exp -> exp PLUSPLUS .)
    FALSE           reduce using rule 32 (exp -> exp PLUSPLUS .)
    $end            reduce using rule 32 (exp -> exp PLUSPLUS .)
    SEMICOLON       reduce using rule 32 (exp -> exp PLUSPLUS .)
    LBRACE          reduce using rule 32 (exp -> exp PLUSPLUS .)


state 26

    (33) exp -> exp MINUSMINUS .

    TIMES           reduce using rule 33 (exp -> exp MINUSMINUS .)
    DIVIDE          reduce using rule 33 (exp -> exp MINUSMINUS .)
    PLUS            reduce using rule 33 (exp -> exp MINUSMINUS .)
    MINUS           reduce using rule 33 (exp -> exp MINUSMINUS .)
    MOD             reduce using rule 33 (exp -> exp MINUSMINUS .)
    PLUSPLUS        reduce using rule 33 (exp -> exp MINUSMINUS .)
    MINUSMINUS      reduce using rule 33 (exp -> exp MINUSMINUS .)
    GE              reduce using rule 33 (exp -> exp MINUSMINUS .)
    GT              reduce using rule 33 (exp -> exp MINUSMINUS .)
    LE              reduce using rule 33 (exp -> exp MINUSMINUS .)
    LT              reduce using rule 33 (exp -> exp MINUSMINUS .)
    EQUALEQUAL      reduce using rule 33 (exp -> exp MINUSMINUS .)
    NOT             reduce using rule 33 (exp -> exp MINUSMINUS .)
    MAYBE           reduce using rule 33 (exp -> exp MINUSMINUS .)
    NUMBER          reduce using rule 33 (exp -> exp MINUSMINUS .)
    STRING          reduce using rule 33 (exp -> exp MINUSMINUS .)
    IDENTIFIER      reduce using rule 33 (exp -> exp MINUSMINUS .)
    SUPPOSE         reduce using rule 33 (exp -> exp MINUSMINUS .)
    SNAKE           reduce using rule 33 (exp -> exp MINUSMINUS .)
    ACCESS          reduce using rule 33 (exp -> exp MINUSMINUS .)
    TRUE            reduce using rule 33 (exp -> exp MINUSMINUS .)
    FALSE           reduce using rule 33 (exp -> exp MINUSMINUS .)
    $end            reduce using rule 33 (exp -> exp MINUSMINUS .)
    SEMICOLON       reduce using rule 33 (exp -> exp MINUSMINUS .)
    LBRACE          reduce using rule 33 (exp -> exp MINUSMINUS .)


state 27

    (41) rel_exp -> exp GE . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 50
    bool                           shift and go to state 12

state 28

    (42) rel_exp -> exp GT . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 51
    bool                           shift and go to state 12

state 29

    (43) rel_exp -> exp LE . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 52
    bool                           shift and go to state 12

state 30

    (44) rel_exp -> exp LT . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 53
    bool                           shift and go to state 12

state 31

    (45) rel_exp -> exp EQUALEQUAL . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 54
    bool                           shift and go to state 12

state 32

    (46) rel_exp -> exp NOT . EQUAL exp

    EQUAL           shift and go to state 55


state 33

    (2) yapl_mnm -> assign_identifier yapl_mnm .

    $end            reduce using rule 2 (yapl_mnm -> assign_identifier yapl_mnm .)
    SEMICOLON       reduce using rule 2 (yapl_mnm -> assign_identifier yapl_mnm .)


state 34

    (3) yapl_mnm -> snake_list yapl_mnm .

    $end            reduce using rule 3 (yapl_mnm -> snake_list yapl_mnm .)
    SEMICOLON       reduce using rule 3 (yapl_mnm -> snake_list yapl_mnm .)


state 35

    (4) yapl_mnm -> snake_list_access yapl_mnm .

    $end            reduce using rule 4 (yapl_mnm -> snake_list_access yapl_mnm .)
    SEMICOLON       reduce using rule 4 (yapl_mnm -> snake_list_access yapl_mnm .)


state 36

    (5) yapl_mnm -> rel_exp yapl_mnm .

    $end            reduce using rule 5 (yapl_mnm -> rel_exp yapl_mnm .)
    SEMICOLON       reduce using rule 5 (yapl_mnm -> rel_exp yapl_mnm .)


state 37

    (7) yapl_mnm -> MAYBE rel_exp . compoundstmt
    (8) yapl_mnm -> MAYBE rel_exp . compoundstmt OR compoundstmt
    (9) compoundstmt -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 57

    compoundstmt                   shift and go to state 56

state 38

    (41) rel_exp -> exp . GE exp
    (42) rel_exp -> exp . GT exp
    (43) rel_exp -> exp . LE exp
    (44) rel_exp -> exp . LT exp
    (45) rel_exp -> exp . EQUALEQUAL exp
    (46) rel_exp -> exp . NOT EQUAL exp
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    GE              shift and go to state 27
    GT              shift and go to state 28
    LE              shift and go to state 29
    LT              shift and go to state 30
    EQUALEQUAL      shift and go to state 31
    NOT             shift and go to state 32
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26


state 39

    (40) exp -> IDENTIFIER .

    GE              reduce using rule 40 (exp -> IDENTIFIER .)
    GT              reduce using rule 40 (exp -> IDENTIFIER .)
    LE              reduce using rule 40 (exp -> IDENTIFIER .)
    LT              reduce using rule 40 (exp -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 40 (exp -> IDENTIFIER .)
    NOT             reduce using rule 40 (exp -> IDENTIFIER .)
    TIMES           reduce using rule 40 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 40 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 40 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 40 (exp -> IDENTIFIER .)
    MOD             reduce using rule 40 (exp -> IDENTIFIER .)
    PLUSPLUS        reduce using rule 40 (exp -> IDENTIFIER .)
    MINUSMINUS      reduce using rule 40 (exp -> IDENTIFIER .)
    MAYBE           reduce using rule 40 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 40 (exp -> IDENTIFIER .)
    STRING          reduce using rule 40 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 40 (exp -> IDENTIFIER .)
    SUPPOSE         reduce using rule 40 (exp -> IDENTIFIER .)
    SNAKE           reduce using rule 40 (exp -> IDENTIFIER .)
    ACCESS          reduce using rule 40 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 40 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 40 (exp -> IDENTIFIER .)
    $end            reduce using rule 40 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 40 (exp -> IDENTIFIER .)
    LBRACE          reduce using rule 40 (exp -> IDENTIFIER .)


state 40

    (34) exp -> MINUS exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 34 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 34 (exp -> MINUS exp .)
    PLUS            reduce using rule 34 (exp -> MINUS exp .)
    MINUS           reduce using rule 34 (exp -> MINUS exp .)
    MOD             reduce using rule 34 (exp -> MINUS exp .)
    PLUSPLUS        reduce using rule 34 (exp -> MINUS exp .)
    MINUSMINUS      reduce using rule 34 (exp -> MINUS exp .)
    GE              reduce using rule 34 (exp -> MINUS exp .)
    GT              reduce using rule 34 (exp -> MINUS exp .)
    LE              reduce using rule 34 (exp -> MINUS exp .)
    LT              reduce using rule 34 (exp -> MINUS exp .)
    EQUALEQUAL      reduce using rule 34 (exp -> MINUS exp .)
    NOT             reduce using rule 34 (exp -> MINUS exp .)
    MAYBE           reduce using rule 34 (exp -> MINUS exp .)
    NUMBER          reduce using rule 34 (exp -> MINUS exp .)
    STRING          reduce using rule 34 (exp -> MINUS exp .)
    IDENTIFIER      reduce using rule 34 (exp -> MINUS exp .)
    SUPPOSE         reduce using rule 34 (exp -> MINUS exp .)
    SNAKE           reduce using rule 34 (exp -> MINUS exp .)
    ACCESS          reduce using rule 34 (exp -> MINUS exp .)
    TRUE            reduce using rule 34 (exp -> MINUS exp .)
    FALSE           reduce using rule 34 (exp -> MINUS exp .)
    $end            reduce using rule 34 (exp -> MINUS exp .)
    SEMICOLON       reduce using rule 34 (exp -> MINUS exp .)
    LBRACE          reduce using rule 34 (exp -> MINUS exp .)

  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! MOD             [ shift and go to state 24 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 41

    (26) assign_identifier -> IDENTIFIER EQUAL . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 59
    bool                           shift and go to state 12

state 42

    (25) assign_identifier -> SUPPOSE IDENTIFIER . EQUAL exp

    EQUAL           shift and go to state 60


state 43

    (12) snake_list -> SNAKE IDENTIFIER . EQUAL num_snake
    (13) snake_list -> SNAKE IDENTIFIER . EQUAL string_snake
    (14) snake_list -> SNAKE IDENTIFIER . EQUAL bool_snake

    EQUAL           shift and go to state 61


state 44

    (15) snake_list_access -> ACCESS IDENTIFIER . NUMBER

    NUMBER          shift and go to state 62


state 45

    (27) exp -> exp TIMES exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 27 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 27 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 27 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 27 (exp -> exp TIMES exp .)
    MOD             reduce using rule 27 (exp -> exp TIMES exp .)
    PLUSPLUS        reduce using rule 27 (exp -> exp TIMES exp .)
    MINUSMINUS      reduce using rule 27 (exp -> exp TIMES exp .)
    GE              reduce using rule 27 (exp -> exp TIMES exp .)
    GT              reduce using rule 27 (exp -> exp TIMES exp .)
    LE              reduce using rule 27 (exp -> exp TIMES exp .)
    LT              reduce using rule 27 (exp -> exp TIMES exp .)
    EQUALEQUAL      reduce using rule 27 (exp -> exp TIMES exp .)
    NOT             reduce using rule 27 (exp -> exp TIMES exp .)
    MAYBE           reduce using rule 27 (exp -> exp TIMES exp .)
    NUMBER          reduce using rule 27 (exp -> exp TIMES exp .)
    STRING          reduce using rule 27 (exp -> exp TIMES exp .)
    IDENTIFIER      reduce using rule 27 (exp -> exp TIMES exp .)
    SUPPOSE         reduce using rule 27 (exp -> exp TIMES exp .)
    SNAKE           reduce using rule 27 (exp -> exp TIMES exp .)
    ACCESS          reduce using rule 27 (exp -> exp TIMES exp .)
    TRUE            reduce using rule 27 (exp -> exp TIMES exp .)
    FALSE           reduce using rule 27 (exp -> exp TIMES exp .)
    $end            reduce using rule 27 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 27 (exp -> exp TIMES exp .)
    LBRACE          reduce using rule 27 (exp -> exp TIMES exp .)

  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! MOD             [ shift and go to state 24 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 46

    (28) exp -> exp DIVIDE exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 28 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 28 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 28 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 28 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 28 (exp -> exp DIVIDE exp .)
    PLUSPLUS        reduce using rule 28 (exp -> exp DIVIDE exp .)
    MINUSMINUS      reduce using rule 28 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 28 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 28 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 28 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 28 (exp -> exp DIVIDE exp .)
    EQUALEQUAL      reduce using rule 28 (exp -> exp DIVIDE exp .)
    NOT             reduce using rule 28 (exp -> exp DIVIDE exp .)
    MAYBE           reduce using rule 28 (exp -> exp DIVIDE exp .)
    NUMBER          reduce using rule 28 (exp -> exp DIVIDE exp .)
    STRING          reduce using rule 28 (exp -> exp DIVIDE exp .)
    IDENTIFIER      reduce using rule 28 (exp -> exp DIVIDE exp .)
    SUPPOSE         reduce using rule 28 (exp -> exp DIVIDE exp .)
    SNAKE           reduce using rule 28 (exp -> exp DIVIDE exp .)
    ACCESS          reduce using rule 28 (exp -> exp DIVIDE exp .)
    TRUE            reduce using rule 28 (exp -> exp DIVIDE exp .)
    FALSE           reduce using rule 28 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 28 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 28 (exp -> exp DIVIDE exp .)
    LBRACE          reduce using rule 28 (exp -> exp DIVIDE exp .)

  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! MOD             [ shift and go to state 24 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 47

    (29) exp -> exp PLUS exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    PLUS            reduce using rule 29 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 29 (exp -> exp PLUS exp .)
    PLUSPLUS        reduce using rule 29 (exp -> exp PLUS exp .)
    MINUSMINUS      reduce using rule 29 (exp -> exp PLUS exp .)
    GE              reduce using rule 29 (exp -> exp PLUS exp .)
    GT              reduce using rule 29 (exp -> exp PLUS exp .)
    LE              reduce using rule 29 (exp -> exp PLUS exp .)
    LT              reduce using rule 29 (exp -> exp PLUS exp .)
    EQUALEQUAL      reduce using rule 29 (exp -> exp PLUS exp .)
    NOT             reduce using rule 29 (exp -> exp PLUS exp .)
    MAYBE           reduce using rule 29 (exp -> exp PLUS exp .)
    NUMBER          reduce using rule 29 (exp -> exp PLUS exp .)
    STRING          reduce using rule 29 (exp -> exp PLUS exp .)
    IDENTIFIER      reduce using rule 29 (exp -> exp PLUS exp .)
    SUPPOSE         reduce using rule 29 (exp -> exp PLUS exp .)
    SNAKE           reduce using rule 29 (exp -> exp PLUS exp .)
    ACCESS          reduce using rule 29 (exp -> exp PLUS exp .)
    TRUE            reduce using rule 29 (exp -> exp PLUS exp .)
    FALSE           reduce using rule 29 (exp -> exp PLUS exp .)
    $end            reduce using rule 29 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 29 (exp -> exp PLUS exp .)
    LBRACE          reduce using rule 29 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    MOD             shift and go to state 24

  ! TIMES           [ reduce using rule 29 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 29 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 29 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 48

    (30) exp -> exp MINUS exp .
    (34) exp -> MINUS exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

  ! reduce/reduce conflict for TIMES resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for PLUS resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for MINUS resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for MOD resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for PLUSPLUS resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for MINUSMINUS resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for GE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for GT resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for LE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for LT resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for NOT resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for MAYBE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for NUMBER resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for STRING resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for SUPPOSE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for SNAKE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for ACCESS resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for TRUE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for FALSE resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for $end resolved using rule 30 (exp -> exp MINUS exp .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 30 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 30 (exp -> exp MINUS exp .)
    PLUSPLUS        reduce using rule 30 (exp -> exp MINUS exp .)
    MINUSMINUS      reduce using rule 30 (exp -> exp MINUS exp .)
    GE              reduce using rule 30 (exp -> exp MINUS exp .)
    GT              reduce using rule 30 (exp -> exp MINUS exp .)
    LE              reduce using rule 30 (exp -> exp MINUS exp .)
    LT              reduce using rule 30 (exp -> exp MINUS exp .)
    EQUALEQUAL      reduce using rule 30 (exp -> exp MINUS exp .)
    NOT             reduce using rule 30 (exp -> exp MINUS exp .)
    MAYBE           reduce using rule 30 (exp -> exp MINUS exp .)
    NUMBER          reduce using rule 30 (exp -> exp MINUS exp .)
    STRING          reduce using rule 30 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 30 (exp -> exp MINUS exp .)
    SUPPOSE         reduce using rule 30 (exp -> exp MINUS exp .)
    SNAKE           reduce using rule 30 (exp -> exp MINUS exp .)
    ACCESS          reduce using rule 30 (exp -> exp MINUS exp .)
    TRUE            reduce using rule 30 (exp -> exp MINUS exp .)
    FALSE           reduce using rule 30 (exp -> exp MINUS exp .)
    $end            reduce using rule 30 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 30 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    MOD             shift and go to state 24

  ! TIMES           [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! TIMES           [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! PLUS            [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! MINUS           [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! MOD             [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! PLUSPLUS        [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! MINUSMINUS      [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! GE              [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! GT              [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! LE              [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! LT              [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! EQUALEQUAL      [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! NOT             [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! MAYBE           [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! NUMBER          [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! STRING          [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! IDENTIFIER      [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! SUPPOSE         [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! SNAKE           [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! ACCESS          [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! TRUE            [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! FALSE           [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! $end            [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! SEMICOLON       [ reduce using rule 34 (exp -> MINUS exp .) ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 49

    (31) exp -> exp MOD exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    TIMES           reduce using rule 31 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 31 (exp -> exp MOD exp .)
    PLUS            reduce using rule 31 (exp -> exp MOD exp .)
    MINUS           reduce using rule 31 (exp -> exp MOD exp .)
    MOD             reduce using rule 31 (exp -> exp MOD exp .)
    PLUSPLUS        reduce using rule 31 (exp -> exp MOD exp .)
    MINUSMINUS      reduce using rule 31 (exp -> exp MOD exp .)
    GE              reduce using rule 31 (exp -> exp MOD exp .)
    GT              reduce using rule 31 (exp -> exp MOD exp .)
    LE              reduce using rule 31 (exp -> exp MOD exp .)
    LT              reduce using rule 31 (exp -> exp MOD exp .)
    EQUALEQUAL      reduce using rule 31 (exp -> exp MOD exp .)
    NOT             reduce using rule 31 (exp -> exp MOD exp .)
    MAYBE           reduce using rule 31 (exp -> exp MOD exp .)
    NUMBER          reduce using rule 31 (exp -> exp MOD exp .)
    STRING          reduce using rule 31 (exp -> exp MOD exp .)
    IDENTIFIER      reduce using rule 31 (exp -> exp MOD exp .)
    SUPPOSE         reduce using rule 31 (exp -> exp MOD exp .)
    SNAKE           reduce using rule 31 (exp -> exp MOD exp .)
    ACCESS          reduce using rule 31 (exp -> exp MOD exp .)
    TRUE            reduce using rule 31 (exp -> exp MOD exp .)
    FALSE           reduce using rule 31 (exp -> exp MOD exp .)
    $end            reduce using rule 31 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 31 (exp -> exp MOD exp .)
    LBRACE          reduce using rule 31 (exp -> exp MOD exp .)

  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! MOD             [ shift and go to state 24 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 50

    (41) rel_exp -> exp GE exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    MAYBE           reduce using rule 41 (rel_exp -> exp GE exp .)
    NUMBER          reduce using rule 41 (rel_exp -> exp GE exp .)
    STRING          reduce using rule 41 (rel_exp -> exp GE exp .)
    IDENTIFIER      reduce using rule 41 (rel_exp -> exp GE exp .)
    SUPPOSE         reduce using rule 41 (rel_exp -> exp GE exp .)
    SNAKE           reduce using rule 41 (rel_exp -> exp GE exp .)
    ACCESS          reduce using rule 41 (rel_exp -> exp GE exp .)
    TRUE            reduce using rule 41 (rel_exp -> exp GE exp .)
    FALSE           reduce using rule 41 (rel_exp -> exp GE exp .)
    $end            reduce using rule 41 (rel_exp -> exp GE exp .)
    SEMICOLON       reduce using rule 41 (rel_exp -> exp GE exp .)
    LBRACE          reduce using rule 41 (rel_exp -> exp GE exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 41 (rel_exp -> exp GE exp .) ]


state 51

    (42) rel_exp -> exp GT exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    MAYBE           reduce using rule 42 (rel_exp -> exp GT exp .)
    NUMBER          reduce using rule 42 (rel_exp -> exp GT exp .)
    STRING          reduce using rule 42 (rel_exp -> exp GT exp .)
    IDENTIFIER      reduce using rule 42 (rel_exp -> exp GT exp .)
    SUPPOSE         reduce using rule 42 (rel_exp -> exp GT exp .)
    SNAKE           reduce using rule 42 (rel_exp -> exp GT exp .)
    ACCESS          reduce using rule 42 (rel_exp -> exp GT exp .)
    TRUE            reduce using rule 42 (rel_exp -> exp GT exp .)
    FALSE           reduce using rule 42 (rel_exp -> exp GT exp .)
    $end            reduce using rule 42 (rel_exp -> exp GT exp .)
    SEMICOLON       reduce using rule 42 (rel_exp -> exp GT exp .)
    LBRACE          reduce using rule 42 (rel_exp -> exp GT exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 42 (rel_exp -> exp GT exp .) ]


state 52

    (43) rel_exp -> exp LE exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    MAYBE           reduce using rule 43 (rel_exp -> exp LE exp .)
    NUMBER          reduce using rule 43 (rel_exp -> exp LE exp .)
    STRING          reduce using rule 43 (rel_exp -> exp LE exp .)
    IDENTIFIER      reduce using rule 43 (rel_exp -> exp LE exp .)
    SUPPOSE         reduce using rule 43 (rel_exp -> exp LE exp .)
    SNAKE           reduce using rule 43 (rel_exp -> exp LE exp .)
    ACCESS          reduce using rule 43 (rel_exp -> exp LE exp .)
    TRUE            reduce using rule 43 (rel_exp -> exp LE exp .)
    FALSE           reduce using rule 43 (rel_exp -> exp LE exp .)
    $end            reduce using rule 43 (rel_exp -> exp LE exp .)
    SEMICOLON       reduce using rule 43 (rel_exp -> exp LE exp .)
    LBRACE          reduce using rule 43 (rel_exp -> exp LE exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 43 (rel_exp -> exp LE exp .) ]


state 53

    (44) rel_exp -> exp LT exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    MAYBE           reduce using rule 44 (rel_exp -> exp LT exp .)
    NUMBER          reduce using rule 44 (rel_exp -> exp LT exp .)
    STRING          reduce using rule 44 (rel_exp -> exp LT exp .)
    IDENTIFIER      reduce using rule 44 (rel_exp -> exp LT exp .)
    SUPPOSE         reduce using rule 44 (rel_exp -> exp LT exp .)
    SNAKE           reduce using rule 44 (rel_exp -> exp LT exp .)
    ACCESS          reduce using rule 44 (rel_exp -> exp LT exp .)
    TRUE            reduce using rule 44 (rel_exp -> exp LT exp .)
    FALSE           reduce using rule 44 (rel_exp -> exp LT exp .)
    $end            reduce using rule 44 (rel_exp -> exp LT exp .)
    SEMICOLON       reduce using rule 44 (rel_exp -> exp LT exp .)
    LBRACE          reduce using rule 44 (rel_exp -> exp LT exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 44 (rel_exp -> exp LT exp .) ]


state 54

    (45) rel_exp -> exp EQUALEQUAL exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    MAYBE           reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    NUMBER          reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    STRING          reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    IDENTIFIER      reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    SUPPOSE         reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    SNAKE           reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    ACCESS          reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    TRUE            reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    FALSE           reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    $end            reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    SEMICOLON       reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    LBRACE          reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 45 (rel_exp -> exp EQUALEQUAL exp .) ]


state 55

    (46) rel_exp -> exp NOT EQUAL . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 63
    bool                           shift and go to state 12

state 56

    (7) yapl_mnm -> MAYBE rel_exp compoundstmt .
    (8) yapl_mnm -> MAYBE rel_exp compoundstmt . OR compoundstmt

    $end            reduce using rule 7 (yapl_mnm -> MAYBE rel_exp compoundstmt .)
    SEMICOLON       reduce using rule 7 (yapl_mnm -> MAYBE rel_exp compoundstmt .)
    OR              shift and go to state 64


state 57

    (9) compoundstmt -> LBRACE . statements RBRACE
    (10) statements -> . yapl_mnm SEMICOLON statements
    (11) statements -> .
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    RBRACE          reduce using rule 11 (statements -> .)
    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    statements                     shift and go to state 65
    yapl_mnm                       shift and go to state 66
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 58

    (30) exp -> exp MINUS . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 67
    bool                           shift and go to state 12

state 59

    (26) assign_identifier -> IDENTIFIER EQUAL exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

  ! shift/reduce conflict for MINUS resolved as shift
    MAYBE           reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    NUMBER          reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    STRING          reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    IDENTIFIER      reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    SUPPOSE         reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    SNAKE           reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    ACCESS          reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    TRUE            reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    FALSE           reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    $end            reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    SEMICOLON       reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 26 (assign_identifier -> IDENTIFIER EQUAL exp .) ]


state 60

    (25) assign_identifier -> SUPPOSE IDENTIFIER EQUAL . exp
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 39
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    exp                            shift and go to state 68
    bool                           shift and go to state 12

state 61

    (12) snake_list -> SNAKE IDENTIFIER EQUAL . num_snake
    (13) snake_list -> SNAKE IDENTIFIER EQUAL . string_snake
    (14) snake_list -> SNAKE IDENTIFIER EQUAL . bool_snake
    (16) num_snake -> . num_snake COMMA NUMBER
    (17) num_snake -> . NUMBER
    (18) num_snake -> . empty
    (19) string_snake -> . string_snake COMMA STRING
    (20) string_snake -> . STRING
    (21) string_snake -> . empty
    (22) bool_snake -> . bool_snake COMMA bool
    (23) bool_snake -> . bool
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUMBER          shift and go to state 72
    STRING          shift and go to state 74
    COMMA           reduce using rule 24 (empty -> .)
    MAYBE           reduce using rule 24 (empty -> .)
    MINUS           reduce using rule 24 (empty -> .)
    IDENTIFIER      reduce using rule 24 (empty -> .)
    SUPPOSE         reduce using rule 24 (empty -> .)
    SNAKE           reduce using rule 24 (empty -> .)
    ACCESS          reduce using rule 24 (empty -> .)
    $end            reduce using rule 24 (empty -> .)
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

  ! NUMBER          [ reduce using rule 24 (empty -> .) ]
  ! STRING          [ reduce using rule 24 (empty -> .) ]
  ! TRUE            [ reduce using rule 24 (empty -> .) ]
  ! FALSE           [ reduce using rule 24 (empty -> .) ]

    num_snake                      shift and go to state 69
    string_snake                   shift and go to state 70
    bool_snake                     shift and go to state 71
    empty                          shift and go to state 73
    bool                           shift and go to state 75

state 62

    (15) snake_list_access -> ACCESS IDENTIFIER NUMBER .

    MAYBE           reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    MINUS           reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    NUMBER          reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    STRING          reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    IDENTIFIER      reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    SUPPOSE         reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    SNAKE           reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    ACCESS          reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    TRUE            reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    FALSE           reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    $end            reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)
    SEMICOLON       reduce using rule 15 (snake_list_access -> ACCESS IDENTIFIER NUMBER .)


state 63

    (46) rel_exp -> exp NOT EQUAL exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

  ! shift/reduce conflict for MINUS resolved as shift
    MAYBE           reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    NUMBER          reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    STRING          reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    IDENTIFIER      reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    SUPPOSE         reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    SNAKE           reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    ACCESS          reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    TRUE            reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    FALSE           reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    $end            reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    SEMICOLON       reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    LBRACE          reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 46 (rel_exp -> exp NOT EQUAL exp .) ]


state 64

    (8) yapl_mnm -> MAYBE rel_exp compoundstmt OR . compoundstmt
    (9) compoundstmt -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 57

    compoundstmt                   shift and go to state 76

state 65

    (9) compoundstmt -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 77


state 66

    (10) statements -> yapl_mnm . SEMICOLON statements

    SEMICOLON       shift and go to state 78


state 67

    (30) exp -> exp MINUS exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

    GE              reduce using rule 30 (exp -> exp MINUS exp .)
    GT              reduce using rule 30 (exp -> exp MINUS exp .)
    LE              reduce using rule 30 (exp -> exp MINUS exp .)
    LT              reduce using rule 30 (exp -> exp MINUS exp .)
    EQUALEQUAL      reduce using rule 30 (exp -> exp MINUS exp .)
    NOT             reduce using rule 30 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 30 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 30 (exp -> exp MINUS exp .)
    PLUSPLUS        reduce using rule 30 (exp -> exp MINUS exp .)
    MINUSMINUS      reduce using rule 30 (exp -> exp MINUS exp .)
    MAYBE           reduce using rule 30 (exp -> exp MINUS exp .)
    NUMBER          reduce using rule 30 (exp -> exp MINUS exp .)
    STRING          reduce using rule 30 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 30 (exp -> exp MINUS exp .)
    SUPPOSE         reduce using rule 30 (exp -> exp MINUS exp .)
    SNAKE           reduce using rule 30 (exp -> exp MINUS exp .)
    ACCESS          reduce using rule 30 (exp -> exp MINUS exp .)
    TRUE            reduce using rule 30 (exp -> exp MINUS exp .)
    FALSE           reduce using rule 30 (exp -> exp MINUS exp .)
    $end            reduce using rule 30 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 30 (exp -> exp MINUS exp .)
    LBRACE          reduce using rule 30 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    MOD             shift and go to state 24

  ! TIMES           [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 30 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 22 ]
  ! MINUS           [ shift and go to state 58 ]
  ! PLUSPLUS        [ shift and go to state 25 ]
  ! MINUSMINUS      [ shift and go to state 26 ]


state 68

    (25) assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .
    (27) exp -> exp . TIMES exp
    (28) exp -> exp . DIVIDE exp
    (29) exp -> exp . PLUS exp
    (30) exp -> exp . MINUS exp
    (31) exp -> exp . MOD exp
    (32) exp -> exp . PLUSPLUS
    (33) exp -> exp . MINUSMINUS

  ! shift/reduce conflict for MINUS resolved as shift
    MAYBE           reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    NUMBER          reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    STRING          reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    IDENTIFIER      reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    SUPPOSE         reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    SNAKE           reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    ACCESS          reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    TRUE            reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    FALSE           reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    $end            reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    SEMICOLON       reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 58
    MOD             shift and go to state 24
    PLUSPLUS        shift and go to state 25
    MINUSMINUS      shift and go to state 26

  ! MINUS           [ reduce using rule 25 (assign_identifier -> SUPPOSE IDENTIFIER EQUAL exp .) ]


state 69

    (12) snake_list -> SNAKE IDENTIFIER EQUAL num_snake .
    (16) num_snake -> num_snake . COMMA NUMBER

    MAYBE           reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    MINUS           reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    NUMBER          reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    STRING          reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    IDENTIFIER      reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    SUPPOSE         reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    SNAKE           reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    ACCESS          reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    TRUE            reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    FALSE           reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    $end            reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    SEMICOLON       reduce using rule 12 (snake_list -> SNAKE IDENTIFIER EQUAL num_snake .)
    COMMA           shift and go to state 79


state 70

    (13) snake_list -> SNAKE IDENTIFIER EQUAL string_snake .
    (19) string_snake -> string_snake . COMMA STRING

    MAYBE           reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    MINUS           reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    NUMBER          reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    STRING          reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    IDENTIFIER      reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    SUPPOSE         reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    SNAKE           reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    ACCESS          reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    TRUE            reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    FALSE           reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    $end            reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    SEMICOLON       reduce using rule 13 (snake_list -> SNAKE IDENTIFIER EQUAL string_snake .)
    COMMA           shift and go to state 80


state 71

    (14) snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .
    (22) bool_snake -> bool_snake . COMMA bool

    MAYBE           reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    MINUS           reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    NUMBER          reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    STRING          reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    IDENTIFIER      reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    SUPPOSE         reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    SNAKE           reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    ACCESS          reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    TRUE            reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    FALSE           reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    $end            reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    SEMICOLON       reduce using rule 14 (snake_list -> SNAKE IDENTIFIER EQUAL bool_snake .)
    COMMA           shift and go to state 81


state 72

    (17) num_snake -> NUMBER .

    COMMA           reduce using rule 17 (num_snake -> NUMBER .)
    MAYBE           reduce using rule 17 (num_snake -> NUMBER .)
    MINUS           reduce using rule 17 (num_snake -> NUMBER .)
    NUMBER          reduce using rule 17 (num_snake -> NUMBER .)
    STRING          reduce using rule 17 (num_snake -> NUMBER .)
    IDENTIFIER      reduce using rule 17 (num_snake -> NUMBER .)
    SUPPOSE         reduce using rule 17 (num_snake -> NUMBER .)
    SNAKE           reduce using rule 17 (num_snake -> NUMBER .)
    ACCESS          reduce using rule 17 (num_snake -> NUMBER .)
    TRUE            reduce using rule 17 (num_snake -> NUMBER .)
    FALSE           reduce using rule 17 (num_snake -> NUMBER .)
    $end            reduce using rule 17 (num_snake -> NUMBER .)
    SEMICOLON       reduce using rule 17 (num_snake -> NUMBER .)


state 73

    (18) num_snake -> empty .
    (21) string_snake -> empty .

  ! reduce/reduce conflict for COMMA resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for MAYBE resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for NUMBER resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for STRING resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for SUPPOSE resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for SNAKE resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for ACCESS resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 18 (num_snake -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 18 (num_snake -> empty .)
    COMMA           reduce using rule 18 (num_snake -> empty .)
    MAYBE           reduce using rule 18 (num_snake -> empty .)
    MINUS           reduce using rule 18 (num_snake -> empty .)
    NUMBER          reduce using rule 18 (num_snake -> empty .)
    STRING          reduce using rule 18 (num_snake -> empty .)
    IDENTIFIER      reduce using rule 18 (num_snake -> empty .)
    SUPPOSE         reduce using rule 18 (num_snake -> empty .)
    SNAKE           reduce using rule 18 (num_snake -> empty .)
    ACCESS          reduce using rule 18 (num_snake -> empty .)
    TRUE            reduce using rule 18 (num_snake -> empty .)
    FALSE           reduce using rule 18 (num_snake -> empty .)
    $end            reduce using rule 18 (num_snake -> empty .)
    SEMICOLON       reduce using rule 18 (num_snake -> empty .)

  ! COMMA           [ reduce using rule 21 (string_snake -> empty .) ]
  ! MAYBE           [ reduce using rule 21 (string_snake -> empty .) ]
  ! MINUS           [ reduce using rule 21 (string_snake -> empty .) ]
  ! NUMBER          [ reduce using rule 21 (string_snake -> empty .) ]
  ! STRING          [ reduce using rule 21 (string_snake -> empty .) ]
  ! IDENTIFIER      [ reduce using rule 21 (string_snake -> empty .) ]
  ! SUPPOSE         [ reduce using rule 21 (string_snake -> empty .) ]
  ! SNAKE           [ reduce using rule 21 (string_snake -> empty .) ]
  ! ACCESS          [ reduce using rule 21 (string_snake -> empty .) ]
  ! TRUE            [ reduce using rule 21 (string_snake -> empty .) ]
  ! FALSE           [ reduce using rule 21 (string_snake -> empty .) ]
  ! $end            [ reduce using rule 21 (string_snake -> empty .) ]
  ! SEMICOLON       [ reduce using rule 21 (string_snake -> empty .) ]


state 74

    (20) string_snake -> STRING .

    COMMA           reduce using rule 20 (string_snake -> STRING .)
    MAYBE           reduce using rule 20 (string_snake -> STRING .)
    MINUS           reduce using rule 20 (string_snake -> STRING .)
    NUMBER          reduce using rule 20 (string_snake -> STRING .)
    STRING          reduce using rule 20 (string_snake -> STRING .)
    IDENTIFIER      reduce using rule 20 (string_snake -> STRING .)
    SUPPOSE         reduce using rule 20 (string_snake -> STRING .)
    SNAKE           reduce using rule 20 (string_snake -> STRING .)
    ACCESS          reduce using rule 20 (string_snake -> STRING .)
    TRUE            reduce using rule 20 (string_snake -> STRING .)
    FALSE           reduce using rule 20 (string_snake -> STRING .)
    $end            reduce using rule 20 (string_snake -> STRING .)
    SEMICOLON       reduce using rule 20 (string_snake -> STRING .)


state 75

    (23) bool_snake -> bool .

    COMMA           reduce using rule 23 (bool_snake -> bool .)
    MAYBE           reduce using rule 23 (bool_snake -> bool .)
    MINUS           reduce using rule 23 (bool_snake -> bool .)
    NUMBER          reduce using rule 23 (bool_snake -> bool .)
    STRING          reduce using rule 23 (bool_snake -> bool .)
    IDENTIFIER      reduce using rule 23 (bool_snake -> bool .)
    SUPPOSE         reduce using rule 23 (bool_snake -> bool .)
    SNAKE           reduce using rule 23 (bool_snake -> bool .)
    ACCESS          reduce using rule 23 (bool_snake -> bool .)
    TRUE            reduce using rule 23 (bool_snake -> bool .)
    FALSE           reduce using rule 23 (bool_snake -> bool .)
    $end            reduce using rule 23 (bool_snake -> bool .)
    SEMICOLON       reduce using rule 23 (bool_snake -> bool .)


state 76

    (8) yapl_mnm -> MAYBE rel_exp compoundstmt OR compoundstmt .

    $end            reduce using rule 8 (yapl_mnm -> MAYBE rel_exp compoundstmt OR compoundstmt .)
    SEMICOLON       reduce using rule 8 (yapl_mnm -> MAYBE rel_exp compoundstmt OR compoundstmt .)


state 77

    (9) compoundstmt -> LBRACE statements RBRACE .

    OR              reduce using rule 9 (compoundstmt -> LBRACE statements RBRACE .)
    $end            reduce using rule 9 (compoundstmt -> LBRACE statements RBRACE .)
    SEMICOLON       reduce using rule 9 (compoundstmt -> LBRACE statements RBRACE .)


state 78

    (10) statements -> yapl_mnm SEMICOLON . statements
    (10) statements -> . yapl_mnm SEMICOLON statements
    (11) statements -> .
    (1) yapl_mnm -> . exp yapl_mnm
    (2) yapl_mnm -> . assign_identifier yapl_mnm
    (3) yapl_mnm -> . snake_list yapl_mnm
    (4) yapl_mnm -> . snake_list_access yapl_mnm
    (5) yapl_mnm -> . rel_exp yapl_mnm
    (6) yapl_mnm -> . empty
    (7) yapl_mnm -> . MAYBE rel_exp compoundstmt
    (8) yapl_mnm -> . MAYBE rel_exp compoundstmt OR compoundstmt
    (27) exp -> . exp TIMES exp
    (28) exp -> . exp DIVIDE exp
    (29) exp -> . exp PLUS exp
    (30) exp -> . exp MINUS exp
    (31) exp -> . exp MOD exp
    (32) exp -> . exp PLUSPLUS
    (33) exp -> . exp MINUSMINUS
    (34) exp -> . MINUS exp
    (35) exp -> . NUMBER
    (36) exp -> . STRING
    (37) exp -> . bool
    (40) exp -> . IDENTIFIER
    (25) assign_identifier -> . SUPPOSE IDENTIFIER EQUAL exp
    (26) assign_identifier -> . IDENTIFIER EQUAL exp
    (12) snake_list -> . SNAKE IDENTIFIER EQUAL num_snake
    (13) snake_list -> . SNAKE IDENTIFIER EQUAL string_snake
    (14) snake_list -> . SNAKE IDENTIFIER EQUAL bool_snake
    (15) snake_list_access -> . ACCESS IDENTIFIER NUMBER
    (41) rel_exp -> . exp GE exp
    (42) rel_exp -> . exp GT exp
    (43) rel_exp -> . exp LE exp
    (44) rel_exp -> . exp LT exp
    (45) rel_exp -> . exp EQUALEQUAL exp
    (46) rel_exp -> . exp NOT EQUAL exp
    (24) empty -> .
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    RBRACE          reduce using rule 11 (statements -> .)
    MAYBE           shift and go to state 8
    MINUS           shift and go to state 9
    NUMBER          shift and go to state 10
    STRING          shift and go to state 11
    IDENTIFIER      shift and go to state 13
    SUPPOSE         shift and go to state 14
    SNAKE           shift and go to state 15
    ACCESS          shift and go to state 16
    SEMICOLON       reduce using rule 24 (empty -> .)
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    yapl_mnm                       shift and go to state 66
    statements                     shift and go to state 82
    exp                            shift and go to state 2
    assign_identifier              shift and go to state 3
    snake_list                     shift and go to state 4
    snake_list_access              shift and go to state 5
    rel_exp                        shift and go to state 6
    empty                          shift and go to state 7
    bool                           shift and go to state 12

state 79

    (16) num_snake -> num_snake COMMA . NUMBER

    NUMBER          shift and go to state 83


state 80

    (19) string_snake -> string_snake COMMA . STRING

    STRING          shift and go to state 84


state 81

    (22) bool_snake -> bool_snake COMMA . bool
    (38) bool -> . TRUE
    (39) bool -> . FALSE

    TRUE            shift and go to state 17
    FALSE           shift and go to state 18

    bool                           shift and go to state 85

state 82

    (10) statements -> yapl_mnm SEMICOLON statements .

    RBRACE          reduce using rule 10 (statements -> yapl_mnm SEMICOLON statements .)


state 83

    (16) num_snake -> num_snake COMMA NUMBER .

    COMMA           reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    MAYBE           reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    MINUS           reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    NUMBER          reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    STRING          reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    IDENTIFIER      reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    SUPPOSE         reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    SNAKE           reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    ACCESS          reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    TRUE            reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    FALSE           reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    $end            reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)
    SEMICOLON       reduce using rule 16 (num_snake -> num_snake COMMA NUMBER .)


state 84

    (19) string_snake -> string_snake COMMA STRING .

    COMMA           reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    MAYBE           reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    MINUS           reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    NUMBER          reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    STRING          reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    IDENTIFIER      reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    SUPPOSE         reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    SNAKE           reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    ACCESS          reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    TRUE            reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    FALSE           reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    $end            reduce using rule 19 (string_snake -> string_snake COMMA STRING .)
    SEMICOLON       reduce using rule 19 (string_snake -> string_snake COMMA STRING .)


state 85

    (22) bool_snake -> bool_snake COMMA bool .

    COMMA           reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    MAYBE           reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    MINUS           reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    NUMBER          reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    STRING          reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    IDENTIFIER      reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    SUPPOSE         reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    SNAKE           reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    ACCESS          reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    TRUE            reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    FALSE           reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    $end            reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)
    SEMICOLON       reduce using rule 22 (bool_snake -> bool_snake COMMA bool .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 61 resolved as shift
WARNING: shift/reduce conflict for STRING in state 61 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 61 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: reduce/reduce conflict in state 48 resolved using rule (exp -> exp MINUS exp)
WARNING: rejected rule (exp -> MINUS exp) in state 48
WARNING: reduce/reduce conflict in state 73 resolved using rule (num_snake -> empty)
WARNING: rejected rule (string_snake -> empty) in state 73
WARNING: Rule (string_snake -> empty) is never reduced
